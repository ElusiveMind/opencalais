<?php
/*
  Copyright (C) 2008 by Phase2 Technology.
  Author(s): Frank Febbraro, Irakli Nadareishvili

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License.
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY. See the LICENSE.txt file for more details.

  $Id$
 */
/**
 * @file
 */

define('CALAIS_PROCESS_NO',         'NO');
define('CALAIS_PROCESS_AUTO',       'AUTO');
define('CALAIS_PROCESS_AUTO_ONCE',  'AUTO_ONCE');
define('CALAIS_PROCESS_MANUAL',     'MANUAL');

module_load_include('inc', 'calais', 'calais.ui');

/**
 * Implementation of hook_perm().
 */
function calais_perm() {
  return array('administer calais', 'access calais');
}

/**
 * Implementation of hook_menu().
 */
function calais_menu() {
  $items = array();

  $items['admin/settings/calais/calais-node'] = array(
    'title' => 'Calais Node Settings',
    'description' => 'Configurations for Calais Integration with content nodes',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('calais_admin_settings'),
    'access arguments' => array('administer calais'),
    'type' => MENU_LOCAL_TASK
  );

  $items['node/%node/calais'] = array(
    'title' => 'Calais',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('calais_keywords_form', 1),
    'access callback' => 'calais_access',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK
  );

  return $items;
}

/**
 * Implementation of hook_access().
 */
function calais_access($node) {
  return user_access('access calais') && calais_processing_type($node) != CALAIS_PROCESS_NO;
}

/**
 * Build the administration page for Calais and Content Types
 */
function calais_admin_settings() {

  $form = array();

  calais_build_entity_settings($form);
  calais_build_nodetype_settings($form);

  $form['#submit'][] = 'calais_admin_settings_submit';

  $form = system_settings_form($form);
  return $form;
}

/**
 * Build the Entity selector. Used for Entity suppression.
 */
function calais_build_entity_settings(&$form, $type = 'global', $name = 'Global', $allow_disable = FALSE) {
  $entity_attributes = array();
  $entities = array_keys(calais_get_entity_vocabularies());
  sort($entities);

  $disabled = FALSE;
  if ($allow_disable) {
    $var_name = "calais_use_global_{$type}";
    $disabled = variable_get($var_name, TRUE);

    $form[$var_name] = array(
      '#type' => 'checkbox',
      '#title' => t('Use Calais Global Entity defaults'),
      '#default_value' => $disabled,
      '#description' => t('If checked, this content type will use the Global Calais Entities.'),
    );

    if ($disabled) {
      $entity_attributes['style'] = 'display:none';
    }

    $field_id = 'edit-'. str_replace(array('][', '_', ' '), '-', $var_name);
    drupal_add_js("$(document).ready(function() {
      $('#$field_id').click(function() {
        $('.{$type}_entities').toggle();
      });
    });", 'inline');
  }

  $params = array('@name' => $name);
  $form["calais_entity_settings_{$type}"] = array(
    '#type' => 'fieldset',
    '#title' => t('@name Calais Entities', $params),
    '#attributes' => array_merge(array('class' => "{$type}_entities"), $entity_attributes),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form["calais_entity_settings_{$type}"]["calais_applied_entities_{$type}"] = array(
    '#type' => 'checkboxes',
    '#title' => t('Which Calais Entities do you wish to use?'),
    '#default_value' => variable_get("calais_applied_entities_{$type}", $entities),
    '#options' => drupal_map_assoc($entities),
    '#description' => t('These are the entities that will get applied to content. If an Entity is not selected then the Calais suggestions will be ignored'),
  );
}

/**
 * Build the node type settings form for Calais integration.
 */
function calais_build_nodetype_settings(&$form) {
  node_types_rebuild();

  $node_types = node_get_types('types', NULL, TRUE);
  $options = array(
    CALAIS_PROCESS_NO => t('Not processed by Calais (default)'),
    CALAIS_PROCESS_MANUAL => t('Have keywords be suggested (manual term association)'),
    CALAIS_PROCESS_AUTO => t('Have keywords automatically applied on every update'),
    CALAIS_PROCESS_AUTO_ONCE => t('Have keywords automatically applied on creation only, and suggested on updates'),
  );

  foreach ($node_types as $nt) {
    $key = drupal_strtolower($nt->type);
    $name = $nt->name;
    $param_name = array('@node' => $name);
    
    $form["calais_{$key}_settings"] = array(
      '#type' => 'fieldset',
      '#title' => t('Processing Settings for @node', $param_name),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );

    $form["calais_{$key}_settings"]["calais_node_{$key}_process"] = array(
      '#type' => 'radios',
      '#parents' => array('calais_node_'. $key .'_process'),
      '#title' => t('Calais Processing'),
      '#default_value' => variable_get("calais_node_{$key}_process", CALAIS_PROCESS_NO),
      '#options' => $options,
    );
    $form["calais_{$key}_settings"]["calais_api_allow_searching_{$key}"] = array(
      '#type' => 'checkbox',
      '#title' => t('Allow Calais Searching'),
      '#default_value' => variable_get("calais_api_allow_searching_{$key}", NULL),
      '#description' => t('Indicates whether future searches can be performed on the extracted metadata by Calais'),
    );
    $form["calais_{$key}_settings"]["calais_api_allow_distribution_{$key}"] = array(
      '#type' => 'checkbox',
      '#title' => t('Allow Calais Distribution'),
      '#default_value' => variable_get("calais_api_allow_distribution_{$key}", NULL),
      '#description' => t('Indicates whether the extracted metadata can be distributed by Calais'),
    );
    $form["calais_{$key}_settings"]["calais_threshold_{$key}"] = array(
      '#type' => 'textfield',
      '#size' => 5,
      '#title' => t('Relevancy Threshold'),
      '#default_value' => variable_get("calais_threshold_{$key}", 0.0),
      '#description' => t('The relevancy threshold for Calais term association. The relevancy score is based on an importance detection for each unique entity and assigns a relevance score in the range 0 - 1 (0 being the least relevant; 1 being the most relevant; The lower the threshold the more terms will appear).'),
    );

    calais_build_entity_settings($form["calais_{$key}_settings"], $key, $name, TRUE);
  }
}

/**
 * Have to override so that we can manage vocabulary - node_type relationships.
 *
 * @param unknown_type $form_id
 * @param unknown_type $form_state
 */
function calais_admin_settings_submit($form, &$form_state) {

  system_settings_form_submit($form, $form_state);

  // Also, set vocabulary-node relationships
  $node_types = node_get_types('types', NULL, TRUE);
  $all_vocabularies = calais_get_entity_vocabularies();
  foreach ($node_types as $nt) {
    $key = drupal_strtolower($nt->type);
    $state = variable_get('calais_node_'. $key .'_process', CALAIS_PROCESS_NO);
    foreach ($all_vocabularies as $entity => $vid) {
      // Clean-up
      db_query("DELETE FROM {vocabulary_node_types} WHERE vid='%d' and type='%s'", $vid, $key);
    }
    if ($state !== CALAIS_PROCESS_NO) {
      // assign all configured calais vocabs to this node type
      $node_vocabularies = calais_get_entity_vocabularies($key);
      foreach ($node_vocabularies as $entity => $vid) {
        db_query("INSERT INTO {vocabulary_node_types} (vid, type) values('%d','%s') ", $vid, $key);
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * Process node updates and if applicable, update the Calais terms.
 */
function calais_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {

  switch ($op) {
    case "delete":
      db_query("DELETE FROM {calais_term_node} WHERE nid=%d", $node->nid);
      break;

    case "insert":
    case "update":
      $process_type = calais_processing_type($node);

      if ($process_type == CALAIS_PROCESS_NO)
        return;

      $date = format_date($node->created, 'custom', 'r');
      $body = filter_xss($node->body, array());
      $node_settings = calais_get_node_settings($node);
      $calais = new Calais($node_settings);
      $keywords = $calais->analyzeXML($node->title, $body, $date);

      if (sizeof($keywords) > 0) {
        db_query("DELETE FROM {calais_term_node} WHERE nid=%d", $node->nid);
      }

      module_invoke_all('calais_preprocess', $node, $keywords);

      $vocabularies = calais_get_entity_vocabularies($node->type);
      $threshold = calais_get_node_threshold($node->type);

      foreach ($keywords as $cat => $metadata) {
        $vid = $vocabularies[$cat];

        foreach ($metadata->terms as $term) {
          calais_associate_term($vid, $term, $node);
          calais_populate_term_guid($vid, $term);
          if ($process_type == CALAIS_PROCESS_AUTO 
              || ($process_type == CALAIS_PROCESS_AUTO_ONCE && $op == "insert") 
              && $term->relevance >= $threshold) {
            calais_assign_to_node($vid, $term, $node);
          }
        }
      }

      module_invoke_all('calais_postprocess', $node, $keywords);

      break;
  }
}

/**
 * Associates a retrieved Calais term with a node.
 *
 * @param $vid  The vocabulary id of the term
 * @param $term The CalaisTerm object
 * @param $node The node for association
 */
function calais_associate_term($vid, $term, $node) {
  $tid = calais_verify_and_get_term($vid, $term, 'calais');
  if ($tid) {
    calais_assign_node_calaisterm($node->nid, $tid, $term->relevance);
  }
  else {
    watchdog('Calais', "Could not create Calais Term: $term->value");
  }  
}

/**
 * For legacy terms with no guid, set the guid if the term name matches.
 *
 * @param $vid  The vocabulary id of the term
 * @param $term The CalaisTerm object
 */
function calais_populate_term_guid($vid, $term) {
  db_query("UPDATE {term_data} SET guid = '%s' WHERE vid = %d AND name = '%s' AND guid IS NULL", $term->guid, $vid, $term->value);  
}

/**
 * Assign the taxonomy term to the node.
 *
 * @param $vid  The vocabulary id of the term
 * @param $term The CalaisTerm object
 * @param $node The node for association
 */
function calais_assign_to_node($vid, $term, $node) {
  $tid = calais_verify_and_get_term($vid, $term, 'taxonomy');
  if ($tid) {
    calais_assign_node_taxonomyterm($node->nid, $node->vid, $tid);
  }
  else {
    watchdog('Calais', "Could not assign Taxonomy Term: $term->value");
  }
}


/**
 * Implementation of hook_calais_preprocess().
 *
 * Make sure that a vocabulary exists for all entities returned, if not, create it.
 */
function calais_calais_preprocess($node, &$keywords) {
  $vocabularies = calais_get_entity_vocabularies();

  foreach ($keywords as $cat => $metadata) {
    $vid = $vocabularies[$cat];

    // Create a vocabulary if we come across an entity that we dont know of.
    if (!$vid) {
      $vid = calais_create_entity_vocabulary($metadata->readable_type());
      $vocabularies[$cat] = $vid;
      variable_set('calais_vocabulary_names', $vocabularies);

      drupal_set_message(t('Added a Vocabulary for the new Calais Entity %entity. You may need to update your Calais Node Settings to take advantage of this new entity.', array('%entity' => $cat)));
    }
  }
}

/**
 * Checks if a specified term exists in a specified vocabulary.
 * If it does not exist - creates it.
 *
 * @param int $vid
 * @param name $term
 *
 * @return int $tid Term id in {calais_term} table
 */
function calais_verify_and_get_term($vid, $term, $module) {

  switch ($module) {
    case 'calais':
      $tablename = "calais_term";
      break;

    case 'taxonomy':
      $tablename = 'term_data';
      break;

    default:
      return NULL;
  }

  $bool = FALSE;
  $bool = db_result(db_query("SELECT count(*) FROM {".$tablename."} where guid='%s' and vid=%d", $term->guid, $vid));

  if (!$bool) {

    $form_values = array('vid' => $vid, 'name' => $term->value, 'guid' => $term->guid);

    switch ($module) {
      case 'calais':
        db_query("INSERT INTO {".$tablename."}(guid,name,vid) values('%s','%s',%d)", $term->guid, $term->value, $vid);
        break;

      case 'taxonomy':
        taxonomy_save_term($form_values);
        break;
    }
  }

  $tid = db_result(db_query("SELECT tid FROM {".$tablename."} WHERE guid='%s' and vid=%d", $term->guid, $vid));
  return $tid;
}

/**
 * Implementation of hook_taxonomy();
 *
 * Post process the insert/update of taxonomy terms to make sure the proper guid gets inserted into the taxonomy tables.
 */
function calais_taxonomy($op, $type, $data) {
  if ($type == 'term' && ($op == 'insert' || $op == 'update') && isset($data['guid'])) {
    db_query("UPDATE {term_data} SET guid = '%s' WHERE tid = %d", $data['guid'], $data['tid']);
  }
}

function calais_assign_node_calaisterm($nid, $tid, $relevance = 0.0) {
  db_query("DELETE FROM {calais_term_node} where nid=%d and tid=%d", $nid, $tid);
  db_query("INSERT INTO {calais_term_node} (nid, tid, relevance) VALUES(%d, %d, %f)", $nid, $tid, $relevance);
}

function calais_assign_node_taxonomyterm($nid, $vid, $tid) {
  db_query("DELETE FROM {term_node} where nid=%d and vid=%d and tid=%d", $nid, $vid, $tid);
  db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES(%d, %d, %d)", $nid, $vid, $tid);
}

/**
 * Determines which processing type (none, manual, auto) is
 * applicable to a node specific node instance passed as an argument.
 *
 * @param mixed $var either a Node object or a valid node_type String
 *
 * @return constant one of: CALAIS_PROCESS_NO, CALAIS_PROCESS_AUTO or CALAIS_PROCESS_MANUAL
 */
function calais_processing_type($var) {

  if (is_object($var)) {
    $nodetype = $var->type;
  }
  else {
    $nodetype = $var;
  }
  $key = drupal_strtolower($nodetype);

  return variable_get("calais_node_{$key}_process", CALAIS_PROCESS_NO);
}

/**
 * Return the Calais parameter settings for the specific node type.
 */
function calais_get_node_settings($node) {
  $key = drupal_strtolower($node->type);
  $settings = array(
    'allowSearch' => variable_get("calais_api_allow_searching_{$key}", FALSE) ? 'true' : 'false',
    'allowDistribution' => variable_get("calais_api_allow_distribution_{$key}", FALSE) ? 'true' : 'false',
  );
  return $settings;
}

/**
 * Return the relevancy threshold settings for the specific node type.
 *
 * @param $node_type Node type.
 */
function calais_get_node_threshold($node_type) {
  $type = drupal_strtolower($node_type);
  return variable_get("calais_threshold_{$type}", 0.0);
}


/**
 * Get a list of the entities that Calais API defines:
 * http://opencalais.mashery.com/page/calaissemanticmetadata
 *
 * IF $type is not specified it will return all known Calais Entities.
 * however if $type is specified it will return only those Entities that the
 * specific node type is interested in, or the global list if no specific node type
 * settings have been configures.
 *
 * @param $type - A node type, if Entities need to be filtered.
 *
 * @return Associative array of [entity_name => vid]'s
 */
function calais_get_entity_vocabularies($type = NULL) {
  $all_vocabs = variable_get('calais_vocabulary_names', FALSE);

  if ($type) {
    $applied_entities = variable_get('calais_applied_entities_global', FALSE);
    if (!variable_get("calais_use_global_{$type}", TRUE)) {
      $applied_entities = variable_get("calais_applied_entities_{$type}", FALSE);
    }

    foreach ($applied_entities as $entity => $apply_entity) {
      if ($apply_entity) {
        $applied_vocabs[$entity] = $all_vocabs[$entity];
      }
    }
  }
  else {
    $applied_vocabs = $all_vocabs;
  }

  return $applied_vocabs;
}

/**
 * Returns the Calais vocabularies that are enabled for this node type.
 * <p>Compare to: calais_api_get_all_entities() which gives entityname/vid pairs.
 * Vocabulary names can be updated by users. Entity names stay as defined
 * by Calais.
 *
 * @param $node_type The node type
 *
 * @return Array of vocabularies keyed on vid;
 */
function calais_get_vocabularies($type = NULL) {

  $vocs = calais_get_entity_vocabularies($type);
  $pattern = implode(",", $vocs);

  if ($type) {

    $result = db_query("SELECT v.vid, v.*, n.type
                        FROM {vocabulary} v
                        LEFT JOIN {vocabulary_node_types} n ON v.vid = n.vid
                        WHERE n.type = '%s' and v.vid in (%s)
                        ORDER BY v.weight, v.name",
      $type, $pattern);
  }
  else {
    $result = db_query('SELECT v.*
                        FROM {vocabulary} v
                        WHERE v.vid in (%s)
                        ORDER BY v.weight, v.name',
      $pattern);
  }

  $vocabularies = array();
  $node_types = array();
  while ($voc = db_fetch_object($result)) {

    // If no node types are associated with a vocabulary, the LEFT JOIN will
    // return a NULL value for type.
    if (isset($voc->type)) {
      $node_types[$voc->vid][$voc->type] = $voc->type;
      unset($voc->type);
      $voc->nodes = $node_types[$voc->vid];
    }
    elseif (!isset($voc->nodes)) {
      $voc->nodes = array();
    }
    $vocabularies[$voc->vid] = $voc;
  }

  return $vocabularies;
}

/**
 * Returns a map of suggested terms for a given vocabulary id. This will return
 * suggested terms for all vocabularies if no vid is specified.
 *
 * @param $nid The node id to get the calais keywords
 * @param $type The node type
 * @param $vid Optional, a specific vocabulary id to return terms
 *
 * @return Array { $vid => array('term1', 'term2', 'term3') }
 */
function calais_get_keywords($nid, $type, $vid = NULL) {
  $threshold = calais_get_node_threshold(drupal_strtolower($type));
  $terms = array();

  if ($vid) {
    $res = db_query(" SELECT name
                        FROM {calais_term} t
                        JOIN {calais_term_node} tn ON tn.tid=t.tid
                        WHERE tn.nid=%d and t.vid=%d and tn.relevance >= %f
                        ORDER BY name asc ", $nid, $vid, $threshold);

    $terms[$vid] = array();
    while ($obj = db_fetch_object($res)) {
      $terms[$vid][] = $obj->name;
    }
  }
  else {
    $vocabularies = calais_get_entity_vocabularies();
    foreach ($vocabularies as $vid) {
      $keys = calais_get_keywords($nid, $type, $vid);
      $terms[$vid] = $keys[$vid];
    }
  }

  return $terms;
}

/**
 * Get the CalaisTerm for the term name and node id. 
 * NOTE: Columns were renamed here so that this object has the same attributes as CalaisTerm for consistency
 *
 * @param $nid The node id to limit the calais term look up
 * @param $term_name The term name to look up
 */
function calais_get_node_term($nid, $term_name) {
  $res = db_query(" SELECT t.name as value, t.guid, tn.relevance
                      FROM {calais_term} t
                      JOIN {calais_term_node} tn ON tn.tid=t.tid
                      WHERE tn.nid=%d and t.name='%s'", $nid, $term_name);
  return db_fetch_object($res);
}

/**
 * Creates a new vocabulary for the supplied Calais entity name.
 */
function calais_create_entity_vocabulary($entity) {
    $description = t("Calais Entity Vocabulary: @name", array('@name' => $entity));
    db_query("INSERT INTO {vocabulary} (name,description,module,tags) values('%s','%s','calais',1)",
              $entity, $description);
    return db_last_insert_id('vocabulary', 'vid');
}


function ____debug($array, $exit = TRUE) {
  echo "<pre>". print_r($array, TRUE) ."</pre>";

  if ($exit)
    exit(0);
}

